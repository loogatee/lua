-----------------------------------------------------------------------------------------------------------
--
--  This script takes a .hex file as input, determines it's length and checksums the data.
--
--  The Length and the Checksum are then embedded within the .hex file, and the new .hex file
--  overwrites the original.
--
--  There are 2 parameters on the command line:
--      1.  Filename, with complete path
--      2.  Address within the hex file which indicates "end-of-data".
--          This Address happens to be the 1st address of the PIC Special Configuration Words.
--              - For the PIC67J94: the address is 0x1FFF0
--              - For the PIC66J94: the address is 0xFFF0
--              - For the PIC27J53: the address is 0x1FFF8
--
--  The PIC source code was written with a compiler-specific pragma which places an empty
--  Length and empty Checksum at absolute address 0x3010.    The Length is 4 bytes and the
--  Checksum is 2 bytes.   The compiler-specific pragma is the following:
--
--      #pragma romdata AppChecksumSection = 0x3010
--      rom LWORD firmware_length   = 0xFFFFFFFF;
--      rom WORD  firmware_checksum = 0xFFFF;
--
--  When the code is compiled and the .hex file is generated, these 3 lines produce the following
--  single line in the .hex file:
--
--      :06301000FFFFFFFFFFFFC0
--  
--  The checksum is generated by adding up all the bytes in the data.  The 6 bytes covering the Length
--  and Checksum are skipped in the calculation.
--
--  The purpose of all this is so the bootloader can verify the integrity of the programmed code at runtime:
--      - when a reset occurs, the bootloader executes
--      - it retrieves the Length of the code from address 0x3010
--      - it retrieves the Checksum of the code from address 0x3014
--      - it computes the checksum (simple addition of all the bytes)
--      - if the checksum matches, it will boot the code
--      - if the checksum does not match, it will remain in the bootloader
--
--
--  ** A note about Array Indexing:
--
--      - 'C' arrays begin at 0, Lua arrays begin at 1
--      - An example of a 256-byte Array:
--             - C:   0..0xFF
--             - Lua: 1..0x100
--
-----------------------------------------------------------------------------------------------------------




require "string"
bit = require("bit")
require "ihex"















--mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
--
--    Beginning of Code.   Perform Initialization.
--
--          - Filename is arg1, Ending_Address is arg2
--          - SearchString is the 0x2010 record
--          - Extended Linear Address is set to 0
--          - Lua array to hold all the data is init'ed to all 0xFF's
--
--
Fname                   = 'ORG.hex'
Fname_out               = 'out.hex'
KeyEndAddr              = tonumber( '1FFF8', 16 )
SearchString            = ':0620100004000000FFFFC8'


hFile,bArray,bArrayLen = ihex.LoadIntelHex( Fname, KeyEndAddr )
if hFile == nil then
    print("LoadIntelHex returned nil")
    return
end



--mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
--
--    Length of the data to be checksummed. 
--
theLen = bArrayLen - 0x2000





--mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
--
--    Calculate the checksum.   Ignore 6 bytes starting at 0x2010 (lua=0x2011)
--    Truncate the checksum to 16-bits.
--
csum = 0
for k2=0x2001,bArrayLen do

    if k2 < 0x2011 or k2 > 0x2016 then
        X    = bArray[ k2 ]
        csum = csum + X
    end

end
theCsum = bit.band(csum, 0xFFFF)




--mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
--
--    Split up the Checksum and Length into their individual bytes
--
b1 = bit.band   ( theLen,  0xff000000 )
b1 = bit.rshift ( b1,      24         )
b2 = bit.band   ( theLen,  0x00ff0000 )
b2 = bit.rshift ( b2,      16         )
b3 = bit.band   ( theLen,  0x0000ff00 )
b3 = bit.rshift ( b3,      8          )
b4 = bit.band   ( theLen,  0x000000ff )
b5 = bit.band   ( theCsum, 0xff00     )
b5 = bit.rshift ( b5,      8          )
b6 = bit.band   ( theCsum, 0x00ff     )



--mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
--
--    Calculate the IntelHex per-line checksum for all the bytes
--
--    The 54 comes from the first 3 bytes of the 2010 record:
--                06 20 10 = 6 + 32 + 16 = 54
--
lcsum = 54 + b1 + b2 + b3 + b4 + b5 + b6
lcsum = bit.bnot(lcsum)
lcsum = lcsum + 1
lcsum = bit.band(lcsum, 0x00ff)




--mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
--
--    Create the line, substitute it into hexFile, and then write it to outfile
--    Note the swapping of the bytes.
--
S2  = string.format(":06201000%02X%02X%02X%02X%02X%02X%02X", b4,b3,b2,b1,b6,b5,lcsum)
S3  = string.gsub(hFile, SearchString, S2)
fd  = assert(io.open(Fname_out, "wb"))
n   = fd:write(S3)
fd:close()
